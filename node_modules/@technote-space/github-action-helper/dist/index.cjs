'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var fs = require('fs');
var path = require('path');
var core = require('@actions/core');
var github = require('@actions/github');
var child_process = require('child_process');
var escape = require('shell-escape');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);
var path__default = /*#__PURE__*/_interopDefaultLegacy(path);
var escape__default = /*#__PURE__*/_interopDefaultLegacy(escape);

const getRef = (ref) => typeof ref === 'string' ? ref : ref.ref;
const getBuildInfo = (filepath) => {
    if (!fs__default["default"].existsSync(filepath)) {
        return false;
    }
    try {
        return JSON.parse(fs__default["default"].readFileSync(filepath, 'utf8'));
    }
    catch {
        return false;
    }
};
const isCloned = (workDir) => fs__default["default"].existsSync(path__default["default"].resolve(workDir, '.git'));
const parseVersion = (version, options) => {
    // https://semver.org/spec/v2.0.0.html
    const regex = options?.strict ?
        /^[vV]?((0|[1-9]\d*)(\.(0|[1-9]\d*)){2})(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/ :
        /^[vV]?((0|[1-9]\d*)(\.(0|[1-9]\d*))*)(?:-((?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\.(?:0|[1-9]\d*|\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\+([0-9a-zA-Z-]+(?:\.[0-9a-zA-Z-]+)*))?$/;
    const matches = version.trim().replace(/^[=v]+/, '').match(regex);
    if (!matches) {
        return undefined;
    }
    const fragments = split(matches[1], '.');
    // eslint-disable-next-line no-magic-numbers
    const length = options?.slice && options.slice < 0 ? (options.length ?? 3) : (options?.slice ?? options?.length ?? 3);
    // eslint-disable-next-line no-magic-numbers
    while (options?.fill !== false && fragments.length < length) {
        fragments.push('0');
    }
    return {
        // eslint-disable-next-line no-magic-numbers
        core: (options?.cut === false ? fragments : fragments.slice(0, options?.slice ?? options?.length ?? 3)).join('.'),
        preRelease: matches[5],
        build: matches[6],
        fragments,
    };
};
const normalizeVersion = (version, options) => {
    const parsed = parseVersion(version, options);
    if (!parsed) {
        return options?.fallback;
    }
    if (options?.onlyCore) {
        return parsed.core;
    }
    return parsed.core + (parsed.preRelease ? `-${parsed.preRelease}` : '') + (parsed.build ? `+${parsed.build}` : '');
};
const isValidSemanticVersioning = (version, strict) => parseVersion(version, { strict }) !== undefined;
/* istanbul ignore next */
/*
 * @deprecated Use isValidSemanticVersioning
 */
const isSemanticVersioningTagName = (tagName) => /^v?\d+(\.\d+)*$/i.test(tagName);
const isRef = (ref) => /^refs\//.test(getRef(ref));
const isBranch = (ref) => /^refs\/heads\//.test(getRef(ref));
const isTagRef = (ref) => /^refs\/tags\//.test(getRef(ref));
const isRemoteBranch = (ref) => /^refs\/remotes\/origin\//.test(getRef(ref));
const isPrRef = (ref) => /^refs\/pull\/\d+\/(merge|head)$/.test(getRef(ref));
const getPrMergeRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/merge');
const getPrHeadRef = (ref) => getRef(ref).replace(/^refs\/pull\/(\d+)\/(merge|head)$/, 'refs/pull/$1/head');
const getRefForUpdate = (ref) => getRef(ref).replace(/^refs\//, '');
const getBranch = (ref, defaultIsEmpty = true) => isBranch(ref) ?
    getRef(ref).replace(/^refs\/heads\//, '') :
    (isRemoteBranch(ref) ? getRef(ref).replace(/^refs\/remotes\/origin\//, '') :
        (defaultIsEmpty ? '' : getRefForUpdate(ref)));
const getPrBranch = (context) => context.payload.pull_request?.head.ref ?? '';
const normalizeRef = (ref) => isRef(ref) ? getRef(ref) : `refs/heads/${getRef(ref)}`;
const trimRef = (ref) => getRef(ref).replace(/^refs\/(heads|tags|pull)\//, '');
const getTag = (ref) => isTagRef(ref) ? trimRef(ref) : '';
const saveTarget = (ref, origin) => isTagRef(ref) ? 'tags' : isPrRef(ref) ? `${origin}/pull` : origin;
// e.g.
//  refs/heads/master
//  refs/pull/123/merge
//  refs/tags/v1.2.3
const getRemoteRefspec = (ref) => normalizeRef(ref);
// e.g.
//  origin/master
//  origin/pull/123/merge
//  tags/v1.2.3
const getLocalRefspec = (ref, origin = 'origin') => `${saveTarget(ref, origin)}/${trimRef(ref)}`;
// e.g.
//  refs/heads/master:refs/remotes/origin/master
//  refs/pull/123/merge:refs/pull/123/merge
//  refs/tags/v1.2.3:refs/tags/v1.2.3
const getRefspec = (ref, origin = 'origin') => `${getRemoteRefspec(ref)}:refs/${getLocalRefspec(ref, `remotes/${origin}`)}`;
const getAccessToken = (required) => core.getInput('GITHUB_TOKEN', { required });
const getOctokit = (token) => github.getOctokit(token ?? getAccessToken(true), {});
const getActor = () => process.env.GITHUB_ACTOR || '';
const escapeRegExp = (text) => text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
const getRegExp = (value) => new RegExp(escapeRegExp(value));
const getPrefixRegExp = (value, flags = '') => new RegExp('^' + escapeRegExp(value), flags);
const getSuffixRegExp = (value, flags = '') => new RegExp(escapeRegExp(value) + '$', flags);
const getBoolValue = (input) => !['false', '0', '', 'no', 'n'].includes(input.trim().toLowerCase());
const uniqueArray = (array) => [...new Set(array)];
const getWorkspace = () => process.env.GITHUB_WORKSPACE || '';
const split = (value, separator = /\r?\n/, limit) => value.length ? value.split(separator, limit) : [];
const getArrayInput = (name, required = false, separator = ',', unique = true) => {
    const arrayInput = core.getInput(name, { required }).split(/\r?\n/).reduce((acc, line) => acc.concat(separator ? line.split(separator) : line).filter(item => item).map(item => item.trim()), []);
    return unique ? uniqueArray(arrayInput) : arrayInput;
};
const sleep = async (millisecond) => new Promise(resolve => setTimeout(resolve, millisecond));
const useNpm = (workDir, pkgManager = '') => 'npm' === pkgManager ||
    ('yarn' !== pkgManager && (fs__default["default"].existsSync(path__default["default"].resolve(workDir, 'package-lock.json')) ||
        !fs__default["default"].existsSync(path__default["default"].resolve(workDir, 'yarn.lock'))));
const replaceAll = (string, key, value) => string.split(key).join(value);
const generateNewVersion = (lastTag, position) => {
    const parsed = parseVersion(lastTag);
    if (!parsed) {
        throw new Error('Invalid versioning');
    }
    const target = Math.max(Math.min(position ?? 2, 2), 0); // eslint-disable-line no-magic-numbers
    parsed.fragments[target] = (Number(parsed.fragments[target]) + 1).toString(); // eslint-disable-line no-magic-numbers
    [...Array(2 - target).keys()].forEach(key => parsed.fragments[2 - key] = '0'); // eslint-disable-line no-magic-numbers
    return 'v' + parsed.fragments.slice(0, 3).join('.'); // eslint-disable-line no-magic-numbers
};
const generateNewPatchVersion = (lastTag) => generateNewVersion(lastTag);
const generateNewMinorVersion = (lastTag) => generateNewVersion(lastTag, 1); // eslint-disable-line no-magic-numbers
const generateNewMajorVersion = (lastTag) => generateNewVersion(lastTag, 0); // eslint-disable-line no-magic-numbers
// eslint-disable-next-line no-magic-numbers
const arrayChunk = (array, size = 100) => {
    const result = [];
    const length = array.length;
    for (let index = 0; index < length; index += size) {
        result.push(array.slice(index, index + size));
    }
    return result;
};
const versionCompare = (version1, version2, checkDifferentLevel = true) => {
    const splitVersion = (version) => version.split('.').map(item => Number(item));
    // eslint-disable-next-line no-magic-numbers
    const compare = (version1, version2, num = 0) => {
        if (version1.length <= num && version2.length <= num) {
            // eslint-disable-next-line no-magic-numbers
            return checkDifferentLevel ? Math.sign(version1.length - version2.length) : 0;
        }
        // eslint-disable-next-line no-magic-numbers
        const val1 = version1[num] ?? (checkDifferentLevel ? 0 : version2[num]);
        // eslint-disable-next-line no-magic-numbers
        const val2 = version2[num] ?? (checkDifferentLevel ? 0 : version1[num]);
        return val1 === val2 ? compare(version1, version2, ++num) : Math.sign(val1 - val2);
    };
    return compare(splitVersion(version1.replace(/^v/, '')), splitVersion(version2.replace(/^v/, '')));
};
// eslint-disable-next-line @typescript-eslint/no-explicit-any,@typescript-eslint/explicit-module-boundary-types
const mask = (value, target = 'token') => {
    Object.keys(value).forEach(key => {
        if (value[key] && typeof value[key] === 'object') {
            value[key] = mask(value[key], target);
        }
        else if (target === key) {
            value[key] = '***';
        }
    });
    return value;
};
const replaceVariables = async (string, variables) => {
    let replaced = string;
    for (const variable of variables) {
        if (getRegExp(`\${${variable.key}}`).test(replaced)) {
            if (typeof variable.replace === 'string') {
                replaced = replaceAll(replaced, `\${${variable.key}}`, variable.replace);
            }
            else {
                replaced = replaceAll(replaced, `\${${variable.key}}`, await variable.replace());
            }
        }
    }
    return replaced;
};
const isCommandDebug = () => core.getInput('UTILS_COMMAND_DEBUG') === 'true' || process.env.UTILS_COMMAND_DEBUG === 'true';
const isOutputDebug = () => core.getInput('UTILS_OUTPUT_DEBUG') === 'true' || process.env.UTILS_OUTPUT_DEBUG === 'true';
// eslint-disable-next-line @typescript-eslint/no-explicit-any
const objectGet = (value, key, defaultValue) => {
    const keys = key.split('.');
    if (!keys.length || !value || !(keys[0] in value)) {
        return defaultValue;
    }
    // eslint-disable-next-line no-magic-numbers
    if (keys.length > 1) {
        // eslint-disable-next-line no-magic-numbers
        return objectGet(value[keys[0]], keys.slice(1).join('.'), defaultValue);
    }
    return value[keys[0]];
};
const ensureNotNullValue = (value, defaultValue) => value ?? defaultValue;
const ensureNotNull = (value) => ensureNotNullValue(value, '');

var utils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    getBuildInfo: getBuildInfo,
    isCloned: isCloned,
    parseVersion: parseVersion,
    normalizeVersion: normalizeVersion,
    isValidSemanticVersioning: isValidSemanticVersioning,
    isSemanticVersioningTagName: isSemanticVersioningTagName,
    isRef: isRef,
    isBranch: isBranch,
    isTagRef: isTagRef,
    isRemoteBranch: isRemoteBranch,
    isPrRef: isPrRef,
    getPrMergeRef: getPrMergeRef,
    getPrHeadRef: getPrHeadRef,
    getRefForUpdate: getRefForUpdate,
    getBranch: getBranch,
    getPrBranch: getPrBranch,
    normalizeRef: normalizeRef,
    trimRef: trimRef,
    getTag: getTag,
    getRemoteRefspec: getRemoteRefspec,
    getLocalRefspec: getLocalRefspec,
    getRefspec: getRefspec,
    getAccessToken: getAccessToken,
    getOctokit: getOctokit,
    getActor: getActor,
    escapeRegExp: escapeRegExp,
    getRegExp: getRegExp,
    getPrefixRegExp: getPrefixRegExp,
    getSuffixRegExp: getSuffixRegExp,
    getBoolValue: getBoolValue,
    uniqueArray: uniqueArray,
    getWorkspace: getWorkspace,
    split: split,
    getArrayInput: getArrayInput,
    sleep: sleep,
    useNpm: useNpm,
    replaceAll: replaceAll,
    generateNewVersion: generateNewVersion,
    generateNewPatchVersion: generateNewPatchVersion,
    generateNewMinorVersion: generateNewMinorVersion,
    generateNewMajorVersion: generateNewMajorVersion,
    arrayChunk: arrayChunk,
    versionCompare: versionCompare,
    mask: mask,
    replaceVariables: replaceVariables,
    isCommandDebug: isCommandDebug,
    isOutputDebug: isOutputDebug,
    objectGet: objectGet,
    ensureNotNullValue: ensureNotNullValue,
    ensureNotNull: ensureNotNull
});

const isRelease = (context) => 'release' === context.eventName;
const isPush = (context) => 'push' === context.eventName;
const isPr = (context) => 'pull_request' === context.eventName || 'pull_request_target' === context.eventName;
const isIssue = (context) => 'issues' === context.eventName;
const isCron = (context) => 'schedule' === context.eventName;
const isCustomEvent = (context) => 'repository_dispatch' === context.eventName;
const isManualEvent = (context) => 'workflow_dispatch' === context.eventName;
const isWorkflowRun = (context) => 'workflow_run' === context.eventName;
const isCreateTag = (context) => 'create' === context.eventName && 'tag' === context.payload.ref_type;
const getTagName = (context) => isRelease(context) ? context.payload.release.tag_name : (/^refs\/tags\//.test(context.ref) ? context.ref.replace(/^refs\/tags\//, '') : '');
const getSender = (context) => context.payload.sender && context.payload.sender.type === 'User' ? context.payload.sender.login : false;
const getRepository = (context) => `${context.repo.owner}/${context.repo.repo}`;
const getGitUrlAuthInfo = (token) => token ? `${getActor()}:${token}@` : '';
const getGitUrlWithToken = (context, token) => `https://${getGitUrlAuthInfo(token)}github.com/${context.repo.owner}/${context.repo.repo}.git`;
const getGitUrl = (context, accessTokenRequired = true) => getGitUrlWithToken(context, getAccessToken(accessTokenRequired));
const showActionInfo = (rootDir, logger, context) => {
    const info = getBuildInfo(path__default["default"].resolve(rootDir, 'build.json'));
    const tagName = getTagName(context);
    const separator = '==================================================';
    logger.log();
    logger.log(separator);
    if (false !== info) {
        if ('owner' in info) {
            logger.log('Version:  %s/%s@%s', info.owner, info.repo, info.tagName);
            logger.log('          %s', info.sha);
        }
        else {
            logger.log('Version:  %s', info.tagName);
            logger.log('          %s', info.sha);
        }
    }
    logger.log('Event:    %s', context.eventName);
    logger.log('Action:   %s', context.payload.action);
    logger.log('sha:      %s', context.sha);
    logger.log('ref:      %s', context.ref);
    if (tagName) {
        logger.log('Tag name: %s', tagName);
    }
    if (context.payload.issue) {
        logger.log('Labels:');
        context.payload.issue.labels.map(label => label.name).forEach(label => logger.log('  - %s', label));
    }
    if (context.payload.pull_request) {
        logger.log('Labels:');
        context.payload.pull_request.labels.map(label => label.name).forEach(label => logger.log('  - %s', label));
    }
    logger.log('owner:    %s', context.repo.owner);
    logger.log('repo:     %s', context.repo.repo);
    logger.log();
    logger.startProcess('Dump context');
    console.log(mask(context));
    logger.startProcess('Dump Payload');
    console.log(mask(context.payload));
    logger.endProcess();
    logger.log(separator);
    logger.log();
};

var contextHelper = /*#__PURE__*/Object.freeze({
    __proto__: null,
    isRelease: isRelease,
    isPush: isPush,
    isPr: isPr,
    isIssue: isIssue,
    isCron: isCron,
    isCustomEvent: isCustomEvent,
    isManualEvent: isManualEvent,
    isWorkflowRun: isWorkflowRun,
    isCreateTag: isCreateTag,
    getTagName: getTagName,
    getSender: getSender,
    getRepository: getRepository,
    getGitUrlWithToken: getGitUrlWithToken,
    getGitUrl: getGitUrl,
    showActionInfo: showActionInfo
});

class ApiHelper {
    constructor(octokit, context, logger, options) {
        Object.defineProperty(this, "octokit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: octokit
        });
        Object.defineProperty(this, "context", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: context
        });
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: logger
        });
        Object.defineProperty(this, "sender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "suppressBPError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "refForUpdate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "prCache", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: {}
        });
        Object.defineProperty(this, "getResponseData", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (response) => (await response).data
        });
        Object.defineProperty(this, "callLogger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (caller) => {
                if (this.logger) {
                    caller(this.logger);
                }
            }
        });
        Object.defineProperty(this, "getSender", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => this.sender ? this.sender : getSender(this.context)
        });
        Object.defineProperty(this, "getRefForUpdate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (encode) => {
                const ref = this.refForUpdate ? this.refForUpdate : (isPrRef(this.context) ? ('heads/' + (await this.getPR()).head.ref) : getRefForUpdate(this.context));
                return encode ? encodeURIComponent(ref) : ref;
            }
        });
        Object.defineProperty(this, "createBlob", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (rootDir, filepath) => {
                const blob = await this.octokit.rest.git.createBlob({
                    ...this.context.repo,
                    content: Buffer.from(fs__default["default"].readFileSync(path__default["default"].resolve(rootDir, filepath), 'utf8')).toString('base64'),
                    encoding: 'base64',
                });
                return {
                    path: filepath,
                    sha: blob.data.sha,
                };
            }
        });
        Object.defineProperty(this, "getCommitSha", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => this.context.payload.pull_request ? this.context.payload.pull_request.head.sha : this.context.sha
        });
        Object.defineProperty(this, "getCommit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => this.getResponseData(this.octokit.rest.git.getCommit({
                ...this.context.repo,
                'commit_sha': this.getCommitSha(),
            }))
        });
        Object.defineProperty(this, "getPR", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const key = parseInt(this.context.payload.number, 10);
                if (!(key in this.prCache)) {
                    this.prCache[key] = await this.getResponseData(this.octokit.rest.pulls.get({
                        ...this.context.repo,
                        'pull_number': this.context.payload.number,
                    }));
                }
                return this.prCache[key];
            }
        });
        Object.defineProperty(this, "filesToBlobs", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (rootDir, files) => await Promise.all(files.map(file => this.createBlob(rootDir, file)))
        });
        Object.defineProperty(this, "createTree", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (blobs) => this.getResponseData(this.octokit.rest.git.createTree({
                ...this.context.repo,
                'base_tree': ensureNotNull(objectGet((await this.getCommit()), 'tree.sha')),
                tree: blobs.map(blob => ({
                    path: blob.path,
                    type: 'blob',
                    mode: '100644',
                    sha: blob.sha,
                })),
            }))
        });
        Object.defineProperty(this, "createCommit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (commitMessage, tree) => this.getResponseData(this.octokit.rest.git.createCommit({
                ...this.context.repo,
                tree: tree.sha,
                parents: [this.getCommitSha()],
                message: commitMessage,
            }))
        });
        Object.defineProperty(this, "getRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (refName) => {
                try {
                    return await this.getResponseData(this.octokit.rest.git.getRef({
                        ...this.context.repo,
                        ref: refName,
                    }));
                }
                catch (error) {
                    return null;
                }
            }
        });
        Object.defineProperty(this, "updateRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (commit, refName, force) => {
                try {
                    await this.octokit.rest.git.updateRef({
                        ...this.context.repo,
                        ref: refName,
                        sha: ensureNotNull(commit.sha),
                        force,
                    });
                    return true;
                }
                catch (error) {
                    if (this.suppressBPError === true && this.isProtectedBranchError(error)) {
                        this.callLogger(logger => logger.warn('Branch is protected.'));
                    }
                    else {
                        throw error;
                    }
                    return false;
                }
            }
        });
        Object.defineProperty(this, "createRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (commit, refName) => {
                await this.octokit.rest.git.createRef({
                    ...this.context.repo,
                    ref: refName,
                    sha: ensureNotNull(commit.sha),
                });
            }
        });
        Object.defineProperty(this, "deleteRef", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (refName) => {
                await this.octokit.rest.git.deleteRef({
                    ...this.context.repo,
                    ref: refName,
                });
            }
        });
        Object.defineProperty(this, "findPullRequest", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (branchName) => {
                const response = await this.octokit.rest.pulls.list({
                    ...this.context.repo,
                    head: `${this.context.repo.owner}:${getBranch(branchName, false)}`,
                });
                if (response.data.length) {
                    return response.data[0];
                }
                return null;
            }
        });
        Object.defineProperty(this, "pullsList", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (params) => this.octokit.paginate(this.octokit.rest.pulls.list, Object.assign({
                sort: 'created',
                direction: 'asc',
            }, params, {
                ...this.context.repo,
            }))
        });
        Object.defineProperty(this, "pullsCreate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (branchName, detail) => this.getResponseData(this.octokit.rest.pulls.create({
                ...this.context.repo,
                head: `${this.context.repo.owner}:${getBranch(branchName, false)}`,
                base: (await this.getRefForUpdate(false)).replace(/^heads\//, ''),
                ...detail,
            }))
        });
        Object.defineProperty(this, "pullsUpdate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (number, detail) => this.getResponseData(this.octokit.rest.pulls.update({
                ...this.context.repo,
                'pull_number': number,
                state: 'open',
                ...detail,
            }))
        });
        Object.defineProperty(this, "getBranchInfo", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (branch) => {
                const branchName = getBranch(branch, false);
                const headName = `heads/${branchName}`;
                const refName = `refs/${headName}`;
                return { branchName, headName, refName };
            }
        });
        Object.defineProperty(this, "createPulls", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (createBranchName, detail) => {
                this.callLogger(async (logger) => logger.startProcess('Creating PullRequest... [%s] -> [%s]', getBranch(createBranchName, false), await this.getRefForUpdate(false)));
                const created = await this.pullsCreate(createBranchName, detail);
                this.callLogger(logger => logger.endProcess());
                return Object.assign({ isPrCreated: true }, created);
            }
        });
        Object.defineProperty(this, "pullsCreateOrUpdate", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (createBranchName, detail) => {
                const pullRequest = await this.findPullRequest(createBranchName);
                if (pullRequest) {
                    this.callLogger(async (logger) => logger.startProcess('Updating PullRequest... [%s] -> [%s]', getBranch(createBranchName, false), await this.getRefForUpdate(false)));
                    const updated = await this.pullsUpdate(pullRequest.number, detail);
                    this.callLogger(logger => logger.endProcess());
                    return Object.assign({ isPrCreated: false }, updated);
                }
                return this.createPulls(createBranchName, detail);
            }
        });
        Object.defineProperty(this, "pullsCreateOrComment", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (createBranchName, detail) => {
                const pullRequest = await this.findPullRequest(createBranchName);
                if (pullRequest) {
                    this.callLogger(async (logger) => logger.startProcess('Creating comment to PullRequest... [%s] -> [%s]', getBranch(createBranchName, false), await this.getRefForUpdate(false)));
                    await this.createCommentToPr(createBranchName, detail.body);
                    this.callLogger(logger => logger.endProcess());
                    return Object.assign({ isPrCreated: false }, pullRequest);
                }
                return this.createPulls(createBranchName, detail);
            }
        });
        Object.defineProperty(this, "createCommentToPr", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (branch, body) => {
                if (!body) {
                    return false;
                }
                const pullRequest = await this.findPullRequest(branch);
                if (!pullRequest) {
                    return false;
                }
                await this.octokit.rest.issues.createComment({
                    ...this.context.repo,
                    'issue_number': pullRequest.number,
                    body,
                });
                return true;
            }
        });
        Object.defineProperty(this, "isProtectedBranchError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (error) => /required status checks?.* (is|are) expected/i.test(error.message)
        });
        Object.defineProperty(this, "checkDiff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (files) => {
                if (!files.length) {
                    this.callLogger(logger => logger.info('There is no diff.'));
                    return false;
                }
                return true;
            }
        });
        Object.defineProperty(this, "prepareCommit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (rootDir, commitMessage, files) => {
                this.callLogger(logger => logger.startProcess('Creating blobs...'));
                const blobs = await this.filesToBlobs(rootDir, files);
                this.callLogger(logger => logger.startProcess('Creating tree...'));
                const tree = await this.createTree(blobs);
                this.callLogger(logger => logger.startProcess('Creating commit... [%s]', tree.sha));
                return this.createCommit(commitMessage, tree);
            }
        });
        Object.defineProperty(this, "commit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (rootDir, commitMessage, files) => {
                if (!this.checkDiff(files)) {
                    return false;
                }
                const commit = await this.prepareCommit(rootDir, commitMessage, files);
                const ref = await this.getRefForUpdate(false);
                this.callLogger(logger => logger.startProcess('Updating ref... [%s] [%s]', ref, commit.sha));
                if (await this.updateRef(commit, ref, false)) {
                    process.env.GITHUB_SHA = commit.sha;
                    core.exportVariable('GITHUB_SHA', commit.sha);
                }
                this.callLogger(logger => logger.endProcess());
                return true;
            }
        });
        Object.defineProperty(this, "createPR", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (rootDir, commitMessage, files, createBranchName, detail) => {
                if (!this.checkDiff(files)) {
                    return false;
                }
                const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
                const commit = await this.prepareCommit(rootDir, commitMessage, files);
                const ref = await this.getRef(headName);
                if (null === ref) {
                    this.callLogger(logger => logger.startProcess('Creating reference... [%s] [%s]', refName, commit.sha));
                    await this.createRef(commit, refName);
                }
                else {
                    this.callLogger(logger => logger.startProcess('Updating reference... [%s] [%s]', refName, commit.sha));
                    await this.updateRef(commit, headName, true);
                }
                return this.pullsCreateOrUpdate(branchName, detail);
            }
        });
        Object.defineProperty(this, "closePR", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (createBranchName, message) => {
                const { branchName, headName, refName } = this.getBranchInfo(createBranchName);
                const pullRequest = await this.findPullRequest(branchName);
                if (pullRequest) {
                    this.callLogger(logger => logger.startProcess('Closing PullRequest... [%s]', branchName));
                    if (message) {
                        await this.createCommentToPr(branchName, message);
                    }
                    await this.pullsUpdate(pullRequest.number, {
                        state: 'closed',
                    });
                }
                else {
                    this.callLogger(logger => logger.info('There is no PullRequest named [%s]', branchName));
                    const ref = await this.getRef(headName);
                    if (!ref) {
                        this.callLogger(logger => logger.info('There is no reference named [%s]', refName));
                        return;
                    }
                }
                this.callLogger(logger => logger.startProcess('Deleting reference... [%s]', refName));
                await this.deleteRef(headName);
                this.callLogger(logger => logger.endProcess());
            }
        });
        Object.defineProperty(this, "getUser", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => {
                const sender = this.getSender();
                if (false === sender) {
                    throw new Error('Sender is not valid.');
                }
                const { data } = await this.octokit.rest.users.getByUsername({
                    username: sender,
                });
                const user = data;
                return {
                    login: user.login,
                    email: ensureNotNull(user.email),
                    name: ensureNotNull(user.name),
                    id: user.id,
                };
            }
        });
        Object.defineProperty(this, "getDefaultBranch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => this.context.payload.repository?.default_branch ?? (await this.octokit.rest.repos.get({
                ...this.context.repo,
            })).data.default_branch
        });
        Object.defineProperty(this, "getTags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => (await this.octokit.paginate(this.octokit.rest.git.listMatchingRefs, {
                ...this.context.repo,
                ref: 'tags/',
            })).map((item) => trimRef(item.ref))
        });
        Object.defineProperty(this, "getLastTag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => 'v' + ((await this.getTags()).filter(tag => /^v?\d+(\.\d+)*$/.test(tag)).sort(versionCompare).reverse()[0]?.replace(/^v/, '') ?? '0.0.0')
        });
        Object.defineProperty(this, "getNewPatchVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => generateNewPatchVersion(await this.getLastTag())
        });
        Object.defineProperty(this, "getNewMinorVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => generateNewMinorVersion(await this.getLastTag())
        });
        Object.defineProperty(this, "getNewMajorVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async () => generateNewMajorVersion(await this.getLastTag())
        });
        this.sender = options?.sender;
        this.refForUpdate = options?.refForUpdate;
        this.suppressBPError = options?.suppressBPError;
    }
}

class CommandError extends Error {
    constructor(message, code) {
        super(message);
        Object.defineProperty(this, "code", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: code
        });
    }
}
class Command {
    constructor(logger, useExec = false) {
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: logger
        });
        Object.defineProperty(this, "useExec", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: useExec
        });
        Object.defineProperty(this, "getCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (command, quiet, suppressError) => command + (quiet ? ' > /dev/null 2>&1' : '') + (suppressError ? ' || :' : '')
        });
        Object.defineProperty(this, "getRejectedErrorMessage", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (command, altCommand, quiet, error) => {
                if ('string' === typeof altCommand) {
                    if (!quiet) {
                        return `command [${altCommand}] exited with code ${error.code}. message: ${error.message}`;
                    }
                    else {
                        return `command [${altCommand}] exited with code ${error.code}.`;
                    }
                }
                else if (!quiet) {
                    return `command [${command}] exited with code ${error.code}. message: ${error.message}`;
                }
                return `command exited with code ${error.code}.`;
            }
        });
        Object.defineProperty(this, "getCommandResult", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (command, altCommand, stderrToStdout, stdout, stderr) => {
                let trimmedStdout = stdout.trim();
                let trimmedStderr = stderr.trim();
                if (trimmedStderr && stderrToStdout) {
                    trimmedStdout += `\n${trimmedStderr}`;
                    trimmedStderr = '';
                }
                return { stdout: trimmedStdout, stderr: trimmedStderr, command: 'string' === typeof altCommand ? altCommand : command };
            }
        });
        Object.defineProperty(this, "outputStdout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (stdout, quiet, suppressOutput) => {
                const trimmedStdout = stdout.trim();
                if (!quiet && !suppressOutput) {
                    if (trimmedStdout) {
                        this.logger.displayStdout(trimmedStdout);
                    }
                }
            }
        });
        Object.defineProperty(this, "outputStderr", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (stderr, quiet, suppressOutput, stderrToStdout) => {
                const trimmedStderr = stderr.trim();
                if (!quiet && !suppressOutput) {
                    if (trimmedStderr) {
                        if (stderrToStdout) {
                            this.logger.displayStdout(trimmedStderr);
                        }
                        else {
                            this.logger.displayStderr(trimmedStderr);
                        }
                    }
                }
            }
        });
        Object.defineProperty(this, "execCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (command, quiet, suppressOutput, stderrToStdout, cwd) => {
                return new Promise((resolve, reject) => {
                    const subProcess = child_process.spawn(command, [], { shell: true, cwd, stdio: [process.stdin, 'pipe', 'pipe'] });
                    let stdout = '';
                    let stderr = '';
                    subProcess.stdout.on('data', (data) => {
                        this.outputStdout(data.toString(), quiet, suppressOutput);
                        stdout += data.toString();
                    });
                    subProcess.stderr.on('data', (data) => {
                        this.outputStderr(data.toString(), quiet, suppressOutput, stderrToStdout);
                        stderr += data.toString();
                    });
                    subProcess.on('error', (err) => {
                        reject(err);
                    });
                    subProcess.on('close', (code) => {
                        if (code) {
                            reject(new CommandError(stderr, code));
                        }
                        resolve({ stdout, stderr });
                    });
                });
            }
        });
        Object.defineProperty(this, "execCallback", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (command, altCommand, quiet, suppressOutput, stderrToStdout, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            resolve, 
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            reject) => (error, stdout, stderr) => {
                if (error) {
                    reject(new Error(this.getRejectedErrorMessage(command, altCommand, quiet, error)));
                }
                else {
                    let trimmedStdout = stdout.trim();
                    let trimmedStderr = stderr.trim();
                    if (!quiet && !suppressOutput) {
                        if (trimmedStdout) {
                            this.logger.displayStdout(trimmedStdout);
                        }
                        if (trimmedStderr) {
                            if (stderrToStdout) {
                                this.logger.displayStdout(trimmedStderr);
                                trimmedStdout += `\n${trimmedStderr}`;
                                trimmedStderr = '';
                            }
                            else {
                                this.logger.displayStderr(trimmedStderr);
                            }
                        }
                    }
                    resolve({ stdout: trimmedStdout, stderr: trimmedStderr, command: 'string' === typeof altCommand ? altCommand : command });
                }
            }
        });
        Object.defineProperty(this, "execAsync", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (options) => {
                const { command, args, cwd, altCommand, quiet = false, suppressError = false, suppressOutput = false, stderrToStdout = false } = options;
                const commandArgs = undefined === args ? '' : escape__default["default"](args.map(item => item.trim()).filter(item => item.length));
                const commandWithArgs = command + (commandArgs.length ? ' ' + commandArgs : '');
                if (undefined !== altCommand) {
                    if (altCommand) {
                        this.logger.displayCommand(altCommand);
                    }
                }
                else if (!quiet) {
                    this.logger.displayCommand(commandWithArgs);
                }
                if (this.useExec) {
                    return new Promise((resolve, reject) => {
                        if (typeof cwd === 'undefined') {
                            child_process.exec(this.getCommand(commandWithArgs, quiet, suppressError), this.execCallback(commandWithArgs, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
                        }
                        else {
                            child_process.exec(this.getCommand(commandWithArgs, quiet, suppressError), { cwd }, this.execCallback(commandWithArgs, altCommand, quiet, suppressOutput, stderrToStdout, resolve, reject));
                        }
                    });
                }
                else {
                    try {
                        const { stdout, stderr } = await this.execCommand(this.getCommand(commandWithArgs, quiet, suppressError), quiet, suppressOutput, stderrToStdout, cwd);
                        return this.getCommandResult(commandWithArgs, altCommand, stderrToStdout, stdout, stderr);
                    }
                    catch (error) {
                        throw new Error(this.getRejectedErrorMessage(command, altCommand, quiet, error));
                    }
                }
            }
        });
    }
}

class GitHelper {
    constructor(logger, options) {
        Object.defineProperty(this, "logger", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: logger
        });
        Object.defineProperty(this, "command", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "cloneDepth", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "filter", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "token", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "origin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: undefined
        });
        Object.defineProperty(this, "quietIfNotOrigin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: true
        });
        Object.defineProperty(this, "shouldSuppressError", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => !isCommandDebug()
        });
        Object.defineProperty(this, "isQuiet", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => !isOutputDebug() && (!this.origin || this.quietIfNotOrigin)
        });
        Object.defineProperty(this, "runCommand", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, commands) => {
                const result = [];
                try {
                    for (const command of (Array.isArray(commands) ? commands : [commands])) {
                        if (typeof command === 'string') {
                            const output = (await this.command.execAsync({ command, cwd: workDir }));
                            result.push({
                                command: output.command,
                                stdout: split(output.stdout),
                                stderr: split(output.stderr),
                            });
                        }
                        else {
                            const output = (await this.command.execAsync({ cwd: workDir, ...command }));
                            result.push({
                                command: output.command,
                                stdout: split(output.stdout),
                                stderr: split(output.stderr),
                            });
                        }
                    }
                    return result;
                }
                catch (error) {
                    console.log();
                    console.log(error);
                    throw error;
                }
            }
        });
        Object.defineProperty(this, "initialize", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, refresh = true) => {
                if (isCloned(workDir) && !refresh) {
                    return;
                }
                if (fs__default["default"].existsSync(workDir)) {
                    await this.runCommand(workDir, { command: 'rm', args: ['-rdf', workDir] });
                }
                fs__default["default"].mkdirSync(workDir, { recursive: true });
                await this.runCommand(workDir, { command: 'git init', args: ['.'] });
            }
        });
        Object.defineProperty(this, "useOrigin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (origin, quiet) => {
                this.origin = typeof origin === 'boolean' ? (origin ? 'origin' : undefined) : origin;
                if (quiet !== undefined) {
                    this.quietIfNotOrigin = quiet;
                }
            }
        });
        Object.defineProperty(this, "getRemoteName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: () => this.origin ?? 'origin'
        });
        Object.defineProperty(this, "getRemote", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: (context) => this.origin ?? getGitUrlWithToken(context, this.token)
        });
        Object.defineProperty(this, "addOrigin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, context) => {
                await this.initialize(workDir, false);
                await this.runCommand(workDir, {
                    command: 'git remote add',
                    args: [this.getRemoteName(), getGitUrlWithToken(context, this.token)],
                    stderrToStdout: this.isQuiet(),
                    altCommand: `git remote add ${this.getRemoteName()}`,
                    suppressError: this.shouldSuppressError(),
                });
            }
        });
        Object.defineProperty(this, "getCurrentBranchName", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => {
                if (!isCloned(workDir)) {
                    return '';
                }
                return (await this.runCommand(workDir, {
                    command: 'git rev-parse',
                    args: ['--abbrev-ref', 'HEAD'],
                    suppressError: this.shouldSuppressError(),
                    stderrToStdout: true,
                }))[0].stdout[0]?.trim() ?? '';
            }
        });
        Object.defineProperty(this, "cloneBranch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch, context) => {
                await this.runCommand(workDir, {
                    command: 'git clone',
                    args: [`--branch=${branch}`, this.cloneDepth, this.getRemote(context), '.'],
                    stderrToStdout: this.isQuiet(),
                    altCommand: `git clone --branch=${branch}`,
                    suppressError: this.shouldSuppressError(),
                });
            }
        });
        Object.defineProperty(this, "clonePR", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, context) => {
                await this.runCommand(workDir, [
                    {
                        command: 'git clone',
                        args: [this.cloneDepth, this.getRemote(context), '.'],
                        stderrToStdout: this.isQuiet(),
                        altCommand: 'git clone',
                        suppressError: this.shouldSuppressError(),
                    },
                    {
                        command: 'git fetch',
                        args: [this.getRemote(context), `+${context.ref}`],
                        quiet: this.isQuiet(),
                        altCommand: `git fetch ${this.getRemoteName()} ${context.ref}`,
                        stderrToStdout: true,
                    },
                    {
                        command: 'git checkout',
                        args: ['-qf', 'FETCH_HEAD'],
                    },
                ]);
            }
        });
        Object.defineProperty(this, "clone", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, context) => {
                if (isCloned(workDir)) {
                    return;
                }
                if (isBranch(context)) {
                    await this.cloneBranch(workDir, getBranch(context), context);
                }
                else if (isPrRef(context)) {
                    await this.clonePR(workDir, context);
                }
                else {
                    await this.checkout(workDir, context);
                }
            }
        });
        Object.defineProperty(this, "gitInit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch) => {
                await this.initialize(workDir);
                await this.runCommand(workDir, { command: 'git checkout', args: ['--orphan', branch], stderrToStdout: true });
            }
        });
        Object.defineProperty(this, "fetchOrigin", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, context, options, refspec) => {
                await this.addOrigin(workDir, context);
                await this.runCommand(workDir, {
                    command: 'git fetch',
                    args: [
                        ...(options ?? []),
                        this.getRemoteName(),
                        ...(refspec ?? []),
                    ],
                    suppressError: this.shouldSuppressError(),
                    stderrToStdout: true,
                });
            }
        });
        Object.defineProperty(this, "checkout", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, context) => {
                await this.fetchOrigin(workDir, context, ['--no-tags'], [getRefspec(context)]);
                await this.runCommand(workDir, [
                    {
                        command: 'git checkout',
                        args: ['-qf', context.sha],
                        stderrToStdout: true,
                    },
                ]);
            }
        });
        Object.defineProperty(this, "fetchBranch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch, context) => {
                const branchName = getBranch(branch, false);
                await this.runCommand(workDir, {
                    command: 'git fetch',
                    args: ['--prune', '--no-tags', '--no-recurse-submodules', this.cloneDepth, this.getRemote(context), `+refs/heads/${branchName}:refs/remotes/${this.getRemoteName()}/${branchName}`],
                    altCommand: `git fetch --prune --no-tags --no-recurse-submodules${this.cloneDepth} ${this.getRemoteName()} +refs/heads/${branchName}:refs/remotes/${this.getRemoteName()}/${branchName}`,
                    suppressError: this.shouldSuppressError(),
                    stderrToStdout: true,
                });
            }
        });
        Object.defineProperty(this, "createBranch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch) => {
                await this.runCommand(workDir, { command: 'git checkout', args: ['-b', branch], stderrToStdout: true });
            }
        });
        Object.defineProperty(this, "switchBranch", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch) => {
                await this.runCommand(workDir, {
                    command: 'git checkout',
                    args: ['-b', branch, `${this.getRemoteName()}/${branch}`],
                    suppressError: this.shouldSuppressError(),
                    stderrToStdout: true,
                });
                await this.runCommand(workDir, {
                    command: 'git checkout',
                    args: [branch],
                    suppressError: this.shouldSuppressError(),
                    stderrToStdout: true,
                });
            }
        });
        Object.defineProperty(this, "config", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, config) => {
                if (config.defaultBranch) {
                    await this.runCommand(workDir, [
                        {
                            command: 'git config',
                            args: ['--global', 'init.defaultBranch', config.defaultBranch],
                        },
                    ]);
                }
                if (config.name) {
                    await this.runCommand(workDir, [
                        {
                            command: 'git config',
                            args: ['user.name', config.name],
                        },
                    ]);
                }
                if (config.email) {
                    await this.runCommand(workDir, [
                        {
                            command: 'git config',
                            args: ['user.email', config.email],
                        },
                    ]);
                }
            }
        });
        Object.defineProperty(this, "getDiff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => (await this.runCommand(workDir, {
                command: 'git status',
                args: ['--short', '-uno'],
                suppressOutput: true,
            }))[0].stdout.filter(line => line.match(/^[MDA]\s+/)).filter(this.filter).map(line => line.replace(/^[MDA]\s+/, ''))
        });
        Object.defineProperty(this, "getRefDiff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, baseRef, compareRef, diffFilter, dot) => {
                const toDiffRef = (ref) => 'HEAD' === ref ? 'HEAD' : (isPrRef(ref) ? ref.replace(/^refs\//, '') : `${this.getRemoteName()}/${getBranch(ref, false)}`);
                return (await this.runCommand(workDir, {
                    command: 'git diff',
                    args: [`${toDiffRef(baseRef)}${dot ?? '...'}${toDiffRef(compareRef)}`, '--name-only', diffFilter ? `--diff-filter=${diffFilter}` : ''],
                    suppressOutput: true,
                }))[0].stdout.filter(item => !!item.trim());
            }
        });
        Object.defineProperty(this, "checkDiff", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => !!(await this.getDiff(workDir)).length
        });
        Object.defineProperty(this, "commit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, message, options) => {
                await this.runCommand(workDir, { command: 'git add', args: ['--all'] });
                if (!options?.allowEmpty && !await this.checkDiff(workDir)) {
                    this.logger.info('There is no diff.');
                    return false;
                }
                await this.makeCommit(workDir, message, options);
                return true;
            }
        });
        Object.defineProperty(this, "makeCommit", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, message, options) => {
                const count = options?.count ?? 10; // eslint-disable-line no-magic-numbers
                const allowEmpty = options?.allowEmpty ?? false;
                const args = options?.args ?? [];
                await this.runCommand(workDir, [
                    {
                        command: 'git commit',
                        args: [allowEmpty ? '--allow-empty' : '', ...args, '-qm', message],
                    },
                    {
                        command: 'git show',
                        args: [`--stat-count=${count}`, 'HEAD'],
                    },
                ]);
            }
        });
        Object.defineProperty(this, "getTags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, options) => (await this.runCommand(workDir, {
                command: 'git tag',
                suppressOutput: options?.suppressOutput || options?.quiet,
                altCommand: options?.quiet ? '' : undefined,
            }))[0].stdout
        });
        Object.defineProperty(this, "fetchTags", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, context, splitSize = 20) => {
                await this.runCommand(workDir, [
                    ...arrayChunk(await this.getTags(workDir, { quiet: true }), splitSize).map(tags => ({
                        command: 'git tag',
                        args: ['-d', ...tags],
                        quiet: true,
                    })),
                    {
                        command: 'git fetch',
                        args: [this.getRemote(context), '--tags'],
                        quiet: this.isQuiet(),
                        altCommand: `git fetch ${this.getRemoteName()} --tags`,
                    },
                ]);
            }
        });
        Object.defineProperty(this, "deleteTag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, tags, context, splitSize = 20) => {
                const getTagRef = (tag) => /^(refs\/)?tags\//.test(tag) ? tag : `tags/${tag}`;
                await this.runCommand(workDir, arrayChunk((typeof tags === 'string' ? [tags] : tags).map(getTagRef), splitSize).map(tags => ({
                    command: 'git push',
                    args: [this.getRemote(context), '--delete', ...tags],
                    stderrToStdout: this.isQuiet(),
                    altCommand: `git push ${this.getRemoteName()} --delete ${tags.join(' ')}`,
                    suppressError: this.shouldSuppressError(),
                })));
                await this.deleteLocalTag(workDir, tags, splitSize);
            }
        });
        Object.defineProperty(this, "copyTag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, newTag, fromTag, context) => {
                await this.deleteTag(workDir, newTag, context);
                await this.runCommand(workDir, [
                    {
                        command: 'git tag',
                        args: [newTag, fromTag],
                    },
                    {
                        command: 'git push',
                        args: [this.getRemote(context), `refs/tags/${newTag}`],
                        stderrToStdout: this.isQuiet(),
                        altCommand: `git push ${this.getRemoteName()} refs/tags/${newTag}`,
                    },
                ]);
            }
        });
        Object.defineProperty(this, "deleteLocalTag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, tags, splitSize = 20) => {
                const getTag = (tag) => tag.replace(/^(refs\/)?tags\//, '');
                await this.runCommand(workDir, arrayChunk((typeof tags === 'string' ? [tags] : tags).map(getTag), splitSize).map(tags => ({
                    command: 'git tag',
                    args: ['-d', ...tags],
                    suppressError: this.shouldSuppressError(),
                    stderrToStdout: true,
                })));
            }
        });
        Object.defineProperty(this, "addLocalTag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, tags) => {
                if ('string' === typeof tags) {
                    await this.runCommand(workDir, { command: 'git tag', args: [tags] });
                }
                else {
                    for (const tag of tags) {
                        await this.addLocalTag(workDir, tag);
                    }
                }
            }
        });
        Object.defineProperty(this, "push", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch, context, options) => {
                const args = [];
                if (options?.withTag) {
                    args.push('--tags');
                }
                if (options?.force) {
                    args.push('--force');
                }
                if (options?.args) {
                    args.push(...options.args);
                }
                await this.runCommand(workDir, {
                    command: 'git push',
                    args: args.concat([this.getRemote(context), `${branch}:refs/heads/${branch}`]),
                    stderrToStdout: this.isQuiet(),
                    altCommand: `git push ${args.concat([this.getRemoteName(), `${branch}:refs/heads/${branch}`]).join(' ')}`,
                });
            }
        });
        Object.defineProperty(this, "forcePush", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir, branch, context) => this.push(workDir, branch, context, { force: true })
        });
        Object.defineProperty(this, "getLastTag", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => {
                if (!isCloned(workDir)) {
                    throw new Error('Not a git repository');
                }
                return 'v' + ((await this.getTags(workDir)).filter(tag => /^v?\d+(\.\d+)*$/.test(tag)).sort(versionCompare).reverse()[0]?.replace(/^v/, '') ?? '0.0.0');
            }
        });
        Object.defineProperty(this, "getNewPatchVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => generateNewPatchVersion(await this.getLastTag(workDir))
        });
        Object.defineProperty(this, "getNewMinorVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => generateNewMinorVersion(await this.getLastTag(workDir))
        });
        Object.defineProperty(this, "getNewMajorVersion", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: async (workDir) => generateNewMajorVersion(await this.getLastTag(workDir))
        });
        this.command = new Command(logger);
        this.token = options?.token ?? getAccessToken(true);
        if (options && options.depth) {
            this.cloneDepth = options.depth > 0 ? `--depth=${options.depth}` : ''; // eslint-disable-line no-magic-numbers
        }
        else {
            this.cloneDepth = '--depth=3';
        }
        if (options && options.filter) {
            this.filter = options.filter;
        }
        else {
            this.filter = (line) => !!line.trim();
        }
    }
}

var types = /*#__PURE__*/Object.freeze({
    __proto__: null
});

exports.ApiHelper = ApiHelper;
exports.Command = Command;
exports.ContextHelper = contextHelper;
exports.GitHelper = GitHelper;
exports.Types = types;
exports.Utils = utils;
